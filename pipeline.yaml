trigger: none

parameters:
- name: modules
  displayName: "Modules to fetch (comma-separated)"
  type: string
  default: "network,compute"
- name: repoName
  displayName: "Azure Repos Repository Name"
  type: string
  default: "terraform-selected-modules"

resources:
  repositories:
    - repository: terraform-modules
      type: github
      name: rachita2901/Terraform-templates
      endpoint: Kartavya0206
      ref: refs/heads/main

stages:
- stage: Fetch_Modules
  displayName: Fetch Selected Terraform Modules
  jobs:
  - job: Fetch
    displayName: Copy Selected Modules
    pool:
      name: Windows-SelfHosted
      demands:
        - Agent.Name -equals testingvm

    steps:
    - checkout: terraform-modules
      displayName: Checkout Terraform Modules

    - powershell: |
        $modules = "${{ parameters.modules }}".Split(",")
        Write-Host "Modules to fetch: $($modules -join ', ')"

        $sourceRoot = "$(Build.SourcesDirectory)\modules"
        $destinationRoot = "$(Build.SourcesDirectory)\selected-modules"

        if (-not (Test-Path $sourceRoot)) {
            Write-Error "Modules directory not found"
            exit 1
        }

        Write-Host "`nAvailable modules:"
        Get-ChildItem $sourceRoot -Directory | ForEach-Object { Write-Host "  - $($_.Name)" }

        New-Item -ItemType Directory -Force -Path $destinationRoot | Out-Null

        foreach ($module in $modules) {
          $module = $module.Trim()
          $sourcePath = Join-Path $sourceRoot $module
          $destinationPath = Join-Path $destinationRoot $module

          if (Test-Path $sourcePath) {
            Write-Host "Copying module: $module"
            Copy-Item -Path $sourcePath -Destination $destinationPath -Recurse -Force
          } else {
            Write-Error "Module '$module' not found"
            exit 1
          }
        }

        Write-Host "`n✓ Modules copied successfully"
      displayName: Copy Selected Modules

    # NEW STEP: Create Azure Repos Repository if it doesn't exist
    - powershell: |
        $repoName = "${{ parameters.repoName }}"
        $orgUrl = "$(System.TeamFoundationCollectionUri)".TrimEnd('/')
        $project = "$(System.TeamProject)"
        $token = "$(System.AccessToken)"
        
        # Create authorization header
        $base64Token = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$token"))
        $headers = @{
            Authorization = "Basic $base64Token"
            "Content-Type" = "application/json"
        }
        
        # Check if repository exists
        $checkUrl = "$orgUrl/$project/_apis/git/repositories/$repoName`?api-version=7.0"
        
        Write-Host "Checking if repository '$repoName' exists..."
        
        try {
            $existingRepo = Invoke-RestMethod -Uri $checkUrl -Headers $headers -Method Get -ErrorAction Stop
            Write-Host "✓ Repository '$repoName' already exists" -ForegroundColor Green
        }
        catch {
            if ($_.Exception.Response.StatusCode -eq 404) {
                Write-Host "Repository not found. Creating new repository '$repoName'..." -ForegroundColor Yellow
                
                # Create repository
                $createUrl = "$orgUrl/$project/_apis/git/repositories?api-version=7.0"
                
                $body = @{
                    name = $repoName
                    project = @{
                        name = $project
                    }
                } | ConvertTo-Json
                
                try {
                    $newRepo = Invoke-RestMethod -Uri $createUrl -Headers $headers -Method Post -Body $body
                    Write-Host "✓ Repository '$repoName' created successfully!" -ForegroundColor Green
                    Write-Host "Repository ID: $($newRepo.id)"
                }
                catch {
                    Write-Error "Failed to create repository: $_"
                    exit 1
                }
            }
            else {
                Write-Error "Error checking repository: $_"
                exit 1
            }
        }
      displayName: Create Azure Repos Repository (if needed)
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)

    # Push to the repository
    - powershell: |
        Set-Location "$(Build.SourcesDirectory)"
        
        Write-Host "Initializing Git repository..."
        git init
        
        git config user.email "pipeline@azuredevops.com"
        git config user.name "Azure Pipeline"
        
        # Build repository URL
        $repoName = "${{ parameters.repoName }}"
        $repoUrl = "https://dev.azure.com/SonuKumar0171/IFI-Terraform-Templates/_git/$repoName"
        
        Write-Host "Repository URL: $repoUrl"
        
        # Add remote
        git remote add origin $repoUrl
        
        # Create branch
        $branchName = "modules-$(Build.BuildId)"
        git checkout -b $branchName
        
        # Add files
        git add selected-modules/
        
        # Commit
        Write-Host "`nCommitting changes..."
        git commit -m "Pipeline Build $(Build.BuildId): Added modules ${{ parameters.modules }}"
        
        # Create auth token
        $token = "$(System.AccessToken)"
        $base64Token = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$token"))
        
        # Push
        Write-Host "`nPushing to Azure Repos..."
        git -c http.extraheader="AUTHORIZATION: Basic $base64Token" push origin $branchName
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host "`n========================================" -ForegroundColor Green
            Write-Host "✓✓✓ SUCCESS! ✓✓✓" -ForegroundColor Green
            Write-Host "========================================" -ForegroundColor Green
            Write-Host "`nModules pushed to Azure Repos!" -ForegroundColor Cyan
            Write-Host "`nView at:" -ForegroundColor Yellow
            Write-Host "$repoUrl`?version=GB$branchName&path=/selected-modules"
        } else {
            Write-Error "Push failed"
            exit 1
        }
      displayName: Push to Azure Repos
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)